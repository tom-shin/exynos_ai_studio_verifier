############################################################################################################
import sys
import os
import time
import paramiko
import re
from tqdm import tqdm
import logging
import socket
import stat
import multiprocessing
import shutil
from colorama import Fore, Back, Style, init
import subprocess

############################################################################################################

logging.basicConfig(level=logging.CRITICAL)


def PRINT_(args):
    # pass
    print(args)
    # logging.info(args)


def auto_str_args(func):
    def wrapper(self, *args, **kwargs):
        new_args = [str(arg) if not isinstance(arg, str) and arg is not None else arg for arg in args]
        new_kwargs = {k: str(v) if not isinstance(v, str) and v is not None else v for k, v in kwargs.items()}
        return func(self, *new_args, **new_kwargs)

    return wrapper


class exynos:
    server_ip = "1.220.53.154"
    port = 63522

    def __init__(self):

        self.ssh = None
        self.remote_directory = "/tmp/enntest"
        self.enntest_cmd_dir = "/data/vendor/enn"
        self.enntest_execution_bin = "/vendor/bin"

    def _enntest_library_binary_push(self, device, nnc_model, input_binary, golden_binary, target_board=""):

        enntest_file = [nnc_model, input_binary, golden_binary]
        for file_ in enntest_file:
            self.upload(device=device, src_path=file_, dst_path=self.enntest_cmd_dir, root_remount=False)

        """
        library_path = os.path.dirname(os.path.abspath(__file__))  # 일반 Python 스크립트 실행 시

        if target_board == "Gen-7(Solomon)":
            Ref_dir = "Gen-7_Solomon"
        elif target_board == "Gen-6(Root)":
            Ref_dir = "Gen-6_Root"
        elif target_board == "Gen-5a(V920_SRDK)":
            Ref_dir = "Gen-5a_V920_SRDK"
        elif target_board == "Gen-5a(V920_SADK)":
            Ref_dir = "Gen-5a_V920_SADK"
        else:
            Ref_dir = "Gen-5_Pamir"

        enntest_lib_bin = os.path.join(library_path, f"{Ref_dir}", 'nnc-model-tester', 'bin', 'EnnTest_v2_lib')
        enntest_service_bin = os.path.join(library_path, f"{Ref_dir}", 'nnc-model-tester', 'bin', 'EnnTest_v2_service')
        enntest_binary = [enntest_lib_bin, enntest_service_bin]
        for file_ in enntest_binary:
            self.upload(device=device, src_path=file_, dst_path=self.enntest_execution_bin, root_remount=False)
        """

    @staticmethod
    def help():

        # Initialize colorama
        init()
        method_prototypes = {
            "quit()": {
                "description": "enntest termination",
                "return": "None",
                "input param.": "None"
            },

            "devices()": {
                "description": "show current available device list",
                "return": "None",
                "input param.": "None"
            },

            "connect(username, password)": {
                "description": "connect to remote server",
                "return": "True: connect success\n            False: connect fail",
                "input param.": "username<str>: authorized user name\n                  password<str>: user password"
            },

            "analyze(device, exe_cmd, nnc_model, input_binary, golden_binary, option, result_dir)": {
                "description": "start enntest with nnc model, input_binary, golden_binary, option",
                "return": "success: full file path for graph visualization\n            False: fail to model analyze",
                "input param.": "device<str>: device for enntest\n                  exe_cmd<str>: cmd for enntest\n             "
                                "       >> EnnTest_v2_lib\n                    >> EnnTest_v2_service\n                "
                                "  nnc_model<str>: full path of nnc model\n                  input_binary<str>: full path of "
                                "input binary\n                  golden_binary<str>: full path of golden_binary\n          "
                                "        optioin<str>: enntest option\n                    >> --profile summary\n          "
                                "          >> --iter #\n                  result_dir<str>: full path where json file "
                                "generated by the enntest reusult is saved"
            },

            "upload(device, src_path, des_path)": {
                "description": "upload file or dir to selected device",
                "return": "True: success\n            False: upload fail",
                "input param.": "device<str>: test device\n                  src_path<str>: source file or directory path\n                  dst_path<str>: destination path for upload "
            },

            "show(profile_file, direction)": {
                "description": "connect to remote server",
                "return": "True: success\n            False: graph view fail",
                "input param.": "profile_file<str>: the full path where the json file generated by the enntest results is "
                                "saved\n                  direction<boolean>: graph direction\n                    >> True: "
                                "horizon view\n                    >> False: vertical view"
            }
        }
        PRINT_("\n[Usage: instance.method(...)]")
        for keys, value_s in method_prototypes.items():
            PRINT_(Fore.GREEN + rf"{keys}")
            for key, value in value_s.items():
                PRINT_(Fore.CYAN + rf"  - {key}: {Fore.WHITE}{value}")
            PRINT_(Style.RESET_ALL + "\n")

    def quit(self):
        if self.ssh:
            PRINT_("Closing previous connection.")
            self.ssh.close()
            self.ssh = None
            PRINT_("Quit Successfully")
        else:
            PRINT_("Already disconnected or no connection")

    @staticmethod
    def _normalize_path(user_input_path):
        # 사용자는 "C:\\Work\\tom" 와 같이 \\을 입력하고 또는 r"C:\Work\tom" 과 같이 r을 사용해서 원시 문자열로 넣어 주는 경우
        # 대다수 임. 일반 유저는 \\ 방법을 넣을 것이고 개발자는 r를 사용할 수 있음.
        # 그런데 생각없는 사람은 그냥 PC에서 경로 복사해서 넣으면 윈도우 환경에 따라 "C:\Work\tom" 처럼 r 도 아니고 \도 한개만
        # 입력하는 경우 있음. 이런경우 경로가 n으로 또는 t로 시작하는 경우 \n, \t로 해석이 되는데 이게 엔터 또는 tap으로 해석이 됨.
        # 그래서 아래처럼 replace를 여러번 해 줌

        normalized_path = user_input_path.replace('\n', '/n').replace('\t', '/t').replace('\\', '/')
        return normalized_path

    def __execute_command(self, command):

        try:

            cmd = command.replace("adb", rf"/home/sam/platform-tools/adb")
            stdin, stdout, stderr = self.ssh.exec_command(cmd)

            # stdin, stdout, stderr = self.ssh.exec_command(command)

            stdout.channel.recv_exit_status()  # Wait for the command to complete
            output = stdout.read().decode()
            error = stderr.read().decode()
            return output, error
        except Exception as e:
            PRINT_(f"An error occurred: {e}")
            return None, str(e)

    def _ensure_remote_dir_exists(self, remote_dir):

        """Ensure the remote directory exists. If it exists, delete it and recreate it."""
        sftp = self.ssh.open_sftp()

        def remove_dir(sftp, path):
            try:
                files = sftp.listdir(path)
                for file in files:
                    file_path = f"{path}/{file}"
                    try:
                        file_attr = sftp.stat(file_path)
                        if stat.S_ISDIR(file_attr.st_mode):
                            remove_dir(sftp, file_path)
                        else:
                            sftp.remove(file_path)
                    except IOError as e:
                        PRINT_(f"An error occurred while removing file {file_path}: {e}")
                sftp.rmdir(path)
            except Exception as e:
                PRINT_(f"An error occurred while removing directory {path}: {e}")

        try:
            sftp.stat(remote_dir)
            # PRINT_(f"Directory {remote_dir} already exists. Removing it.")
            remove_dir(sftp, remote_dir)
        except FileNotFoundError:
            PRINT_("")
        except Exception as e:
            PRINT_(f"An error occurred: {e}")

        try:
            sftp.mkdir(remote_dir)
            # PRINT_(f"Directory {remote_dir} created.")
        except Exception as e:
            PRINT_(f"Failed to create directory {remote_dir}: {e}")
        finally:
            sftp.close()

    def _ssh_connect(self, username, password, timeout):

        try:
            self.ssh = paramiko.SSHClient()
            self.ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            self.ssh.connect(hostname=self.server_ip, port=self.port, username=username, password=password,
                             timeout=timeout)
            PRINT_(f"Successfully connected to the server.")
            return True

        except paramiko.AuthenticationException:
            PRINT_("Authentication failed")
        except paramiko.SSHException as sshException:
            PRINT_(f"SSH error: {sshException}")
        except socket.timeout:
            PRINT_("Connection timed out")
        except Exception as e:
            PRINT_(f"Other error: {e}")

        if self.ssh:
            # PRINT_("Closing previous connection.")
            self.ssh.close()
            self.ssh = None

        return False

    def __upload_directory(self, sftp, local_dir, remote_dir):

        for root, dirs, files in os.walk(local_dir):
            rel_path = os.path.relpath(root, local_dir)
            remote_path = os.path.join(remote_dir, rel_path).replace("\\", "/")
            try:
                sftp.mkdir(remote_path)
            except IOError:
                pass  # Directory might already exist
            for file in files:
                local_file = os.path.join(root, file)
                remote_file = os.path.join(remote_path, file).replace("\\", "/")
                # sftp.put(local_file, remote_file)
                self.__upload_file(sftp, local_file, remote_file)

    @staticmethod
    def __upload_file(sftp, local_file, remote_file):

        file_size = os.path.getsize(local_file)
        with tqdm(total=file_size, unit='B', unit_scale=True, desc='Uploading') as pbar:
            def callback(transferred, total):
                pbar.update(transferred - pbar.n)

            sftp.put(local_file, remote_file, callback=callback)

    def _upload2server(self, src_path, remote_directory="/tmp/enntest"):

        if not self.ssh:
            PRINT_("No SSH connection. Upload aborted.")
            return False

        dest_path = ""
        try:
            sftp = self.ssh.open_sftp()

            # Ensure the remote directory exists
            self._ensure_remote_dir_exists(remote_directory)

            if os.path.isdir(src_path):
                # src_path가 폴더인 경우
                folder_name = os.path.basename(src_path)
                dest_path = os.path.join(remote_directory, folder_name).replace("\\", "/")
                self._ensure_remote_dir_exists(dest_path)
                self.__upload_directory(sftp, src_path, dest_path)
            elif os.path.isfile(src_path):
                # src_path가 파일인 경우
                dest_path = os.path.join(remote_directory, os.path.basename(src_path)).replace("\\", "/")
                self.__upload_file(sftp, src_path, dest_path)

            sftp.close()
            return True, dest_path
        except Exception as e:
            PRINT_(f"Fail to upload: {e}")
            return False, None

    def _download_from_server(self, dst_path, remote_directory="/tmp/enntest"):

        if not self.ssh:
            PRINT_("No SSH connection. Download aborted.")
            return None

        try:
            sftp = self.ssh.open_sftp()

            def download_dir(sftp, remote_dir, local_dir):
                os.makedirs(local_dir, exist_ok=True)
                for item in sftp.listdir_attr(remote_dir):
                    remote_item_path = os.path.join(remote_dir, item.filename).replace("\\", "/")
                    local_item_path = os.path.join(local_dir, item.filename)
                    if stat.S_ISDIR(item.st_mode):
                        download_dir(sftp, remote_item_path, local_item_path)
                    else:
                        file_size = item.st_size
                        with tqdm(total=file_size, unit='B', unit_scale=True,
                                  desc=f'Downloading {item.filename}') as pbar:
                            def callback(transferred, total):
                                pbar.update(transferred - pbar.n)

                            sftp.get(remote_item_path, local_item_path, callback=callback)

            if not os.path.exists(dst_path):
                os.makedirs(dst_path, exist_ok=True)

            download_dir(sftp, remote_directory, dst_path)

            sftp.close()
            PRINT_(f"Successfully downloaded {remote_directory} to {dst_path}")
            return None
        except Exception as e:
            PRINT_(f"Failed to download: {e}")
            return None

    def _device_root_remount(self, device=''):

        if len(device) == 0:
            PRINT_("No Device Selected")
            return

        cmds = [
            rf"adb -s {device} root",
            rf"adb -s {device} remount"
        ]
        for cmd in cmds:
            output, error = self.__execute_command(command=cmd)
            PRINT_(cmd)
            PRINT_(output)

    def _adb_pull_overwrite(self, local_path, remote_path, device_id, root_remount=False):

        if root_remount:
            self._device_root_remount(device=device_id)

        cmds = [
            rf'adb -s {device_id} pull {remote_path} {local_path}'
        ]

        for cmd in cmds:
            output, error = self.__execute_command(command=cmd)
            PRINT_(cmd)
            PRINT_(output)

    def _adb_push_overwrite(self, local_path, remote_path, device_id, root_remount=False):

        if root_remount:
            self._device_root_remount(device=device_id)

        cmds = [
            rf'adb -s {device_id} push {local_path} {remote_path}',
            rf'adb -s {device_id} shell "chmod -R 777 {remote_path}"'
        ]

        for cmd in cmds:
            output, error = self.__execute_command(command=cmd)
            PRINT_(cmd)
            PRINT_(output)

    def devices(self):

        if not self.ssh:
            PRINT_("No SSH connection.")
            return

        command = "adb devices"
        cmd = command.replace("adb", rf"/home/sam/platform-tools/adb")

        stdin, stdout, stderr = self.ssh.exec_command(cmd)
        output = stdout.read().decode()
        error = stderr.read().decode()

        if error:
            PRINT_(rf"Devices Error:{error}")

        PRINT_(output)

    def upload(self, device, src_path, dst_path, root_remount=False):

        if not self.ssh:
            PRINT_("No SSH connection.")
            return

        result, path = self._upload2server(src_path=src_path, remote_directory=self.remote_directory)
        if result:
            self._adb_push_overwrite(local_path=path, remote_path=dst_path, device_id=device, root_remount=root_remount)
        else:
            PRINT_("Upload Fail")

    def download(self, device, src_path, dst_path, root_remount=False):

        if not self.ssh:
            PRINT_("No SSH connection.")
            return

        src_path = self._normalize_path(user_input_path=src_path)
        dst_path = self._normalize_path(user_input_path=dst_path)

        self._adb_pull_overwrite(local_path="/tmp/enntest", remote_path=src_path, device_id=device,
                                 root_remount=root_remount)
        self._download_from_server(dst_path=dst_path, remote_directory=self.remote_directory)

    def connect(self, username, password, timeout=30):

        if self.ssh:
            # PRINT_("Closing previous connection.")
            self.ssh.close()
            self.ssh = None

        ret = self._ssh_connect(username=username, password=password, timeout=timeout)

        if ret:
            # Ensure the remote directory exists
            self._ensure_remote_dir_exists(self.remote_directory)

    def remove_all(self, device):

        if not self.ssh:
            PRINT_("No SSH connection.")
            return

        # output, error = self.__execute_command(command=rf"adb -s {device} get-state")
        # if "device" not in output:
        #     PRINT_(f"device is not available state: {output}")
        #     return

        # remove all cmd binary            
        # output, error = self.__execute_command(
        #     command=rf"adb -s {device} shell 'rm -rf {self.enntest_execution_bin}/EnnTest*'")
        # if output:
        #     PRINT_(f"{output}")
        #
        # if error:
        #     PRINT_(f"Error:\n{error}")

        # remove all nnc, golden, input binary
        output, error = self.__execute_command(command=rf"adb -s {device} shell 'rm -rf {self.enntest_cmd_dir}/*'")
        if output:
            PRINT_(f"{output}")

        if error:
            PRINT_(f"Error:\n{error}")

    @auto_str_args
    def analyze(self, device, exe_cmd, nnc_model, input_binary, golden_binary, result_dir='', filename='',
                threshold=0.0001, option='', target_board=""):

        if not self.ssh:
            PRINT_("No SSH connection.")
            return

        nnc_model = self._normalize_path(user_input_path=nnc_model)
        input_binary = self._normalize_path(user_input_path=input_binary)
        golden_binary = self._normalize_path(user_input_path=golden_binary)
        result_dir = self._normalize_path(user_input_path=result_dir)
        cleaned_result = ""

        if not self.ssh:
            PRINT_("No SSH connection. Model upload aborted.")
            return False, cleaned_result

        if device == '':
            PRINT_("No selected device")
            return False, cleaned_result
        elif nnc_model == '':
            PRINT_("No selected nnc model")
            return False, cleaned_result
        elif input_binary == '':
            PRINT_("No selected input_binary")
            return False
        elif golden_binary == '':
            PRINT_("No selected golden_binary")
            return False, cleaned_result
        elif exe_cmd == '':
            PRINT_("No EnnTest Command")
            return False, cleaned_result

        self._device_root_remount(device=device)

        """ 선택한 device 정상 상태인지 확인 """
        # output, error = self.__execute_command(command=rf"adb -s {device} get-state")
        # if "device" not in output:
        #     PRINT_(f"device is not available state: {output}")
        #     return False

        self._enntest_library_binary_push(device=device, nnc_model=nnc_model, input_binary=input_binary,
                                          golden_binary=golden_binary, target_board=target_board)

        nnc_model = os.path.basename(nnc_model)
        input_binary = os.path.basename(input_binary)
        golden_binary = os.path.basename(golden_binary)

        test_cmd = f'adb -s {device} shell "cd {self.enntest_cmd_dir}; {exe_cmd} --model {nnc_model} --input {input_binary} --golden {golden_binary} {option}"'
        PRINT_(f"Executing: {test_cmd}\n")
        enntest_result, enntest_error = self.__execute_command(command=test_cmd)
        if enntest_result:
            print(
                f"\n\n >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n")
            print(f"{enntest_result}")
            print(
                f"\n\n >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n")

        if enntest_error:
            PRINT_(f"Error:\n{enntest_error}")
            return False, cleaned_result

        # formatted_time = time.strftime("%Y%m%d%H%M%S", time.localtime())
        rename_output = f"{filename}_enntest_result.txt"
        if result_dir == '':
            local_output_path = os.path.join(os.getcwd(), rename_output)
        else:
            local_output_path = os.path.join(result_dir, rename_output)

        # save enntest result
        Pass_ = False

        if enntest_result:
            # ANSI escape codes 제거
            ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
            cleaned_result = ansi_escape.sub('', enntest_result)
            with open(local_output_path, "w") as result_file:
                result_file.write(cleaned_result)
            if "PASSED" in cleaned_result.split("\n")[-2]:
                Pass_ = True

        # PRINT_("++++++++++++++++++++++++++++++", local_output_path)
        # return local_output_path  # full local path to save generated output.json file

        # 파일 이름 수정 및 이동
        base_dir, original_filename = os.path.split(local_output_path)  # 디렉토리와 파일 이름 분리
        filename_without_ext, ext = os.path.splitext(original_filename)  # 파일 이름과 확장자 분리

        # Pass/Fail에 따라 파일 이름 수정
        if Pass_:
            new_filename = f"{filename_without_ext}_Pass{ext}"
        else:
            new_filename = f"{filename_without_ext}_Fail{ext}"

        new_output_path = os.path.join(base_dir, new_filename)

        # 파일 이름 변경
        shutil.move(local_output_path, new_output_path)  # 기존 파일을 새 이름으로 이동
        return Pass_, cleaned_result


def local_run_enntest(nnc_files, input_golden_pairs, out_dir, target_board):
    DeviceTargetDir = "/data/vendor/enn"
    ProfileCMD = "EnnTest_v2_lib"
    ProfileOption = "--profile summary --monitor_iter 1 --iter 1 --useSNR"
    ANSI_Escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')

    DeviceId = None  # "0000100d0f246013"
    NNC_Model = nnc_files[0]

    # Device 권한 설정
    if DeviceId is None:
        auth = [f"adb root", f"adb remount"]
    else:
        auth = [f"adb -s {DeviceId} root", f"adb -s {DeviceId} remount"]

    for cmd in auth:
        subprocess.run(cmd)

    # Model Binary push
    if DeviceId is None:
        subprocess.run(rf"adb push {NNC_Model} .{DeviceTargetDir}")
    else:
        subprocess.run(rf"adb -s {DeviceId} push {NNC_Model} .{DeviceTargetDir}")

    # print(input_golden_pairs)
    CHECK_ENNTEST = []
    failed_pairs = []  # 실패한 파일 쌍을 저장할 리스트
    ANSI_Escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')  # ANSI 이스케이프 코드 제거용 정규식

    for paired_list in input_golden_pairs:
        InputBinary = paired_list[0]
        GoldenBinary = paired_list[1]
        # print("++", InputBinary)
        # print("++", GoldenBinary)

        if DeviceId is None:
            subprocess.run(rf"adb push {InputBinary} .{DeviceTargetDir}")
            subprocess.run(rf"adb push {GoldenBinary} .{DeviceTargetDir}")
        else:
            subprocess.run(rf"adb -s {DeviceId} push {InputBinary} .{DeviceTargetDir}")
            subprocess.run(rf"adb -s {DeviceId} push {GoldenBinary} .{DeviceTargetDir}")

        # Profile 시작
        nnc_model = os.path.join(DeviceTargetDir, os.path.basename(NNC_Model)).replace('\\', '/')
        input_binary = os.path.join(DeviceTargetDir, os.path.basename(InputBinary)).replace('\\', '/')
        golden_binary = os.path.join(DeviceTargetDir, os.path.basename(GoldenBinary)).replace('\\', '/')

        execute_cmd = [
            "adb", *(["-s", DeviceId] if DeviceId else []), "shell",
            ProfileCMD,
            "--model", nnc_model,
            "--input", input_binary,
            "--golden", golden_binary,
            ProfileOption
        ]
        result = subprocess.run(execute_cmd, capture_output=True, text=True)

        # 출력값을 파일로 저장
        filename = f"{os.path.basename(InputBinary)}_{os.path.basename(GoldenBinary)}_result_enntest.txt"
        SaveOutput = os.path.join(out_dir, filename).replace('\\', '/')

        with open(SaveOutput, "w", encoding="utf-8") as f:
            cleaned_result = ANSI_Escape.sub('', result.stdout)  # ANSI 이스케이프 코드 제거
            f.write(cleaned_result)

        # 결과 확인
        if "PASSED" in cleaned_result.split("\n")[-2]:
            CHECK_ENNTEST.append(True)
        else:
            CHECK_ENNTEST.append(False)
            failed_pairs.append(cleaned_result)

        print(f"Saved: {SaveOutput}")

    if all(CHECK_ENNTEST):  # 모든 값이 True인 경우
        return True, failed_pairs  # 실패한 쌍도 반환
    else:
        return False, failed_pairs  # 실패한 쌍도 반환


def run_enntest(nnc_files, input_golden_pairs, out_dir, target_board):
    # print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")
    # print(nnc_files)
    # for i in input_golden_pairs:
    #     print(i)
    # print(out_dir)
    # print("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++")

    CHECK_ENNTEST = []
    failed_pairs = []  # 실패한 파일 쌍을 저장할 리스트

    if target_board == "Gen-6(Root)":
        server_ip = "1.220.53.154"  # 원격 서버 IP 주소
        port = 63522  # SSH 포트
        username = "sam"  # SSH 사용자 이름
        password = "Thunder$@88"  # SSH 비밀번호
        device = "0000100d8e38c0e0"
    else:
        return False, failed_pairs

    ssh_test = exynos()
    ssh_test.connect(username, password)

    ssh_test.remove_all(device=device)

    # BASE_DIR = os.path.dirname(os.path.abspath(__file__))

    cmd = "EnnTest_v2_lib"
    option = "--profile summary --monitor_iter 1 --iter 1 --useSNR"

    model = nnc_files[0]

    for input_file, golden_file in input_golden_pairs:
        in_filename, in_extension = os.path.splitext(os.path.basename(input_file))
        g_filename, g_extension = os.path.splitext(os.path.basename(golden_file))

        result_file, err_log = ssh_test.analyze(device=device, exe_cmd=cmd, nnc_model=model,
                                                input_binary=input_file,
                                                golden_binary=golden_file,
                                                result_dir=out_dir, filename=f"{in_filename}_{g_filename}",
                                                option=option,
                                                target_board=target_board)

        CHECK_ENNTEST.append(result_file)

        if not result_file:  # result_file이 False인 경우
            failed_pairs.append(err_log)  # 실패한 쌍을 저장

    if all(CHECK_ENNTEST):  # 모든 값이 True인 경우
        return True, failed_pairs  # 실패한 쌍도 반환
    else:
        return False, failed_pairs  # 실패한 쌍도 반환


# 함수 실행 예시
if __name__ == "__main__":
    server_ip = "1.220.53.154"  # 원격 서버 IP 주소
    port = 63522  # SSH 포트
    username = "sam"  # SSH 사용자 이름
    password = "Thunder$@88"  # SSH 비밀번호
    device = "0000100d8e38c0e0"

    ssh_test = exynos()
    ssh_test.connect(username, password)

    ssh_test.devices()
    ssh_test.remove_all(device=device)

    BASE_DIR = os.path.dirname(os.path.abspath(__file__))

    cmd = "EnnTest_v2_lib"
    option = "--profile summary --monitor_iter 1 --iter 1 --useSNR"

    # model = rf"{BASE_DIR}\nnc-model-tester\sample_model\NPU_EdgeTPU\Mobilenet_Edgetpu_O2_Multicore.nnc"
    # input_ = rf"{BASE_DIR}\nnc-model-tester\sample_model\NPU_EdgeTPU\Mobilenet_Edgetpu_O2_Multicore_input_data.bin"
    # gold = rf"{BASE_DIR}\nnc-model-tester\sample_model\NPU_EdgeTPU\Mobilenet_Edgetpu_O2_Multicore_golden_data.bin"

    model = r"C:\Work\tom\python_project\ai_studio_verifier\ai_studio_2_x\test_model_repo\test_model\mobilenetv2-7\Compiler_result\mobilenetv2-7_simplify_O2_SingleCore.nnc"
    gold = r"C:\Work\tom\python_project\ai_studio_verifier\ai_studio_2_x\test_model_repo\test_model\mobilenetv2-7\Converter_result\NPU_mobilenetv2-7\testvector\inout\golden_data_float32.bin"
    input_ = r"C:\Work\tom\python_project\ai_studio_verifier\ai_studio_2_x\test_model_repo\test_model\mobilenetv2-7\Converter_result\NPU_mobilenetv2-7\testvector\inout\input_data_float32.bin"
    outdir = r"C:\Work\tom\python_project\ai_studio_verifier\ai_studio_2_x\test_model_repo\test_model\mobilenetv2-7\Converter_result\NPU_mobilenetv2-7\testvector\inout"

    result_file = ssh_test.analyze(device=device, exe_cmd=cmd, nnc_model=model, input_binary=input_, golden_binary=gold,
                                   result_dir=outdir, option=option)
